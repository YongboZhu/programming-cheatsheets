\section{Programming in Bash}
\subsection{Shebang}
The shebang (\texttt{\#!}) at the head of a script indicates an 
interpreter for execution, as in \texttt{\#!/bin/bash}.
Lines starting with a \texttt{\#} (with the exception of shebang) 
are comments and thus won't be executed.

\subsection{Quoting and literals}
\textbf{Single quotes} \texttt{''} preserve the literal value of characters enclosed within them.
A single quote may not appear between single quotes, even when escaped, but may appear between \textbf{double quotes} \texttt{""}.
They work similarly, with an exception that the shell expands any variables that appear within them.

\subsection{Variables}
\textbf{Variable} names are case sensitive.
They can contain digits and underscores as well,
but a name starting with a digit is not allowed.
Example: 
\begin{minted}{bash}
var="kind"
echo ${var}ness # kindness
\end{minted}

Special variables:
\begin{enumx}
    \item \texttt{\$0}: name of the script itself. \texttt{\$1}, \texttt{\$2}, \texttt{\$3}, \ldots: the first, second, etc. argument. \texttt{shift} removes first argument and advances rest of them forward.
    \item \texttt{\$*} and \texttt{\$@} denote all the positional parameters.
    \item \texttt{\$\#}: the number of positional parameters
    \item \texttt{\$?}: most recently executed command exit status.
    \item \texttt{\$\$}: the process ID of the shell.
    \item \texttt{\$!}: the process ID of the most recently executed command.
\end{enumx}

 It reads a line of input from standard input or a file passed as an argument to its -u flag, and assigns it to a variable. In Linux based shells, like Bash, it is present as a shell built in function, and not as a separate executable file.[1]

To read a line of input:
\begin{enumx}
\item [\cmd] \textbf{read} reads a line from the stdin and splits it into fields:
\item [\texttt{n}] returns after reading $n$ characters, 
\item [\texttt{n}] displays a prompt 
\end{enumx}

\subsection{Expansions}
There is a tilde expansion as well.
The expressions \texttt{$\sim$} and \texttt{$\sim$<user>} expand to the home directory of the current (or given) user. 

\subsubsection{Brace expansion}
Brace expansion is used when we need to generate all possible string combinations.
Both of the commands produce the same output:
\begin{minted}{bash}
echo {I,really,love,dots}.
echo I. really. love. dots.
\end{minted}

\textbf{Warning}: it does not expand the variables (\texttt{\$var}), which is done later, but supports ranges (sequences) of characters:
\begin{minted}{bash}
echo {a..t}
a b c d e f g h i j k l m n o p q r s t
\end{minted}

and (maybe zero paded or with an increment rate) integers, assuming the Bash version is 4 or newer:

\begin{minted}{bash}
echo {01..10..1}.~
01. 02. 03. 04. 05. 06. 07. 08. 09. 10.
\end{minted}

\subsubsection{Parameter expansion}
\begin{enumerate}
\item \mintinline{bash}{${var^}}, \mintinline{bash}{${var,}} convert first character to upper and lowercase. \mintinline{bash}{${var^^}}, \mintinline{bash}{${var,,}} do the same to all characters.

\mintinline{bash}{${var~}}, \mintinline{bash}{${var~~}} are undocumented now: they reverse the case.

In case of the array expansion, every expanded element changes case, no matter what.

\item \mintinline{bash}{${var#pattern}} removes the \texttt{pattern} from the beginning of the string, if possible.

It's greedy variant is \mintinline{bash}{${var##pattern}}.

\mintinline{bash}{${var%pattern}} and \mintinline{bash}{${var%%pattern}} do the same, but  from the end of the string.

Application: extracting parts of a filename.

\item \mintinline{bash}{${var/pattern/string}} performs a single search and replace operation.

\mintinline{bash}{${var//pattern/string}} searches for all occurrences of the pattern and replaces them.

\item \mintinline{bash}{${#var}} returns length of the string.

\item \mintinline{bash}{${var:offset:length}} skips first \texttt{offset} characters from \texttt{var} and truncates the output to given length.
\texttt{:length} may be skipped.

Negative values separated with extra space are accepted.

\item \mintinline{bash}{${var:-value}} uses a default value, if \texttt{var} is empty or unset.

\mintinline{bash}{${var:=value}} does the same, but performs an assignment as well.

\mintinline{bash}{${var:+value}} uses an alternative value if \texttt{var} isn't empty or unset!
\end{enumerate}

\subsubsection{Command substitution}
To execute commands in a subshell and then pass their standard output, use \mintinline{bash}{$( commands )}.

\subsubsection{Process substitution}
This kind of substitution (where input or output of a command appears as a temporary file) is performed simultaneously with the following: arithmetic and parameter expansions, command substitution.
\begin{minted}{bash}
<( ... ) # not specified by POSIX!
>( ... )
\end{minted}

\subsubsection{Arithmetic expansion}
The arithmetic expression \mintinline{bash}{$(( ... ))} is evaluated and expands to the result.
Bash guarantees that the output will be a one-word integer.

\subsection{Streams}
There are always three default files open:
\begin{enumx}
\item \emph{stdin} (the keyboard, file descriptor 0),
\item \emph{stdout} (the screen, file descriptor 1) and
\item \emph{stderr} (error messages output, file descriptor 2).
\end{enumx}

These \textbf{streams} can be \textbf{redirected}:
\begin{itemx} 
\item \texttt{cmd > file} redirects to a file (overwrites),
\item \texttt{cmd >{}> file} appends instead,
\item \texttt{m>n} (or \texttt{m>\&n}) redirects a file descriptor to a file 
(or another file descriptor), 
\item \texttt{\&>file} redirects both stdout and stderr to a file;
\item \texttt{:> file} truncates file to zero length and
\item \texttt{|} (pipe) serves as a command chaining tool.
\end{itemx}

\subsection{Control flow statements}
The one-line constructs \texttt{\&\&} and \texttt{||} work like logical and $\wedge$ and logical or $\vee$.

\subsubsection{Conditionals}
Here at least one statement must be specified inside every block,
but one can use a single colon (:) as a null statement to avoid
rewriting the code.

\begin{minted}{bash}
if condition; then
  commands
elif second_condition; then
  some_commands
else
  other_commands	
fi

select word in "foo" "bar" "baz"
do
  echo "Your word is $word".
done
\end{minted}

There is also a case instruction:
\begin{minted}{bash}
case $fruit in
  banana)
    echo "Bananas are awry."
    ;;
  orange|apple)
    echo "Ugh..."
    exit 1
    ;;
  *)
    echo "Unknown fruit!"
esac
\end{minted}



\subsubsection{Testing conditions}
Remember that \texttt{test} command follows symbolic links (except for the \texttt{-h} test).
\begin{itemx} 
\item \textbf{File tests}:
\begin{enumx}
    \item \texttt{-e} file exists, 
    \texttt{-s} file is nonempty. 
    \item \texttt{-d} directory, 
    \texttt{-f} regular file, 
    \texttt{-h} symbolic link. 
    \item \texttt{-b} block device, 
    \texttt{-c} character device, 
    \texttt{-p} named pipe, 
    \texttt{-S} socket.
\end{enumx}
\item \textbf{File permissions}:
\begin{enumx}
    \item \texttt{-r} readable,
    \texttt{-w} writable,
    \texttt{-x} executable,
    \item \texttt{-u} setuid,
    \texttt{-g} setgid,
    \texttt{-k} sticky bit.
\end{enumx}
\item \textbf{String tests}: \texttt{-z} empty, \texttt{-n} nonempty.
\item \textbf{Arithmetic tests}: 
\texttt{-eq} $=$, 
\texttt{-ne} $\neq$, 
\texttt{-lt} $<$, 
\texttt{-gt} $>$, 
\texttt{-le} $\le$, 
\texttt{-ge} $\ge$.
\end{itemx}

\subsubsection{Loops}
\begin{minted}{bash}
for var in "the first" "the second"; do
  echo "${var}"
done

for (( i = 1; i <= 10; i++ )); do
  echo "i = ${i}."
done # C-style

while read myline; do
  echo "It says ${myline}"
done < some_file
\end{minted}

As Bash Guide for Beginners by M. Garrels says:
\begin{enumx}
\item the \texttt{break} statement is used to 
exit the current loop before its normal ending. 
\item the \texttt{continue} statement resumes iteration 
of an enclosing while, until, select or for loop.
\end{enumx}


% special files: /dev/null, /dev/zero, /proc/...

% special meaning of < > ; | * ? - one has to escape them
% ' '
% " "
